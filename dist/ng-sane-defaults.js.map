{"version":3,"sources":["src/ng-sane-defaults.module.ts"],"names":[],"mappings":"AAAA,CAAC;IAGG,OAAO;SACF,MAAM,CAAC,kBAAkB,EAAE,EAAE,CAAC;SAC9B,MAAM,CAAC,CAAC,kBAAkB,EAAE,SAAS,CAAC,CAAC,CAAC;IAE7C,SAAS,SAAS,CAAC,gBAA0C;QACzD,gBAAgB,CAAC,SAAS,GAAG,sBAAsB,CAC/C,gBAAgB,CAAC,SAAS,CAC7B,CAAC;IACN,CAAC;IAED,SAAS,sBAAsB,CAC3B,iBAAwD;QAExD,OAAO,SAAS,CAAC;QACjB;;;;WAIG;QACH,SAAS,SAAS,CAEd,UAAoD,EACpD,OAAmC;;YAEnC,+GAA+G;YAC/G,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,OAAO,OAAO,KAAK,QAAQ;gBAC7D,OAAO,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,OAAc,CAAC,CAAC;YACpE,IACI,OAAO,UAAU,KAAK,QAAQ;gBAC9B,OAAO,UAAU,KAAK,QAAQ;gBAE9B,OAAO,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,OAAc,CAAC,CAAC;YAEpE,oEAAoE;YACpE,IAAM,UAAU,GACZ,OAAO,UAAU,KAAK,QAAQ;gBAC1B,CAAC,WAAG,GAAC,UAAU,IAAG,OAAQ,MAC1B,CAAC,CAAC,UAAU,CAAC;oCAEV,GAAG;gBACV,IAAM,SAAO,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;gBAEhC,wCAAwC;gBACxC,IAAI,OAAO,SAAO,CAAC,UAAU,KAAK,UAAU;sCAAW;gBAEvD,8HAA8H;gBAC9H,IACI,MAAM,CAAC,mBAAmB,CAAC,SAAO,CAAC,UAAU,CAAC,CAAC,OAAO,CAClD,WAAW,CACd,KAAK,CAAC,CAAC;sCAEC;gBAEb,qEAAqE;gBACrE,IAAM,MAAM,GACR,SAAO,CAAC,UAAU,CAAC,SAAS,CAAC,OAAO,CAAC;gBAEzC,+BAA+B;gBAC/B,SAAO,CAAC,UAAU,CAAC,SAAS,CAAC,OAAO,GAAG,SAAS,OAAO;oBACnD,IAAM,QAAQ,GAAI,SAAO,CAAC,UAAmB,CAAC,SAAS,CAAC;oBAExD,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;wBAC9B,KAAK,IAAM,IAAI,IAAI,QAAQ,EAAE;4BACzB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE;gCACpB,IAAI,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;6BAC/B;yBACJ;qBACJ;oBAED,wCAAwC;oBACxC,OAAO,OAAO,MAAM,KAAK,UAAU;wBAC/B,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;wBACnB,CAAC,CAAC,KAAK,CAAC,CAAC;gBACjB,CAAC,CAAC;YACN,CAAC;YAnCD,KAAK,IAAM,GAAG,IAAI,UAAU;wBAAjB,GAAG;aAmCb;YAED,OAAO,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QACpD,CAAC;IACL,CAAC;AACL,CAAC,CAAC,EAAE,CAAC","file":"ng-sane-defaults.js","sourcesContent":["(function() {\n    type Dict<T = any> = { [key: number]: T; [key: string]: T };\n\n    angular\n        .module(\"ng-sane-defaults\", [])\n        .config([\"$compileProvider\", configure]);\n\n    function configure($compileProvider: angular.ICompileProvider) {\n        $compileProvider.component = patchRegisterComponent(\n            $compileProvider.component\n        );\n    }\n\n    function patchRegisterComponent(\n        registerComponent: angular.ICompileProvider[\"component\"]\n    ) {\n        return component;\n        /**\n         *\n         * @param nameOrDict name or Dictionary of component names and their options\n         * @param options options for the component if the first parameter is the name\n         */\n        function component(\n            this: angular.ICompileProvider,\n            nameOrDict: string | Dict<angular.IComponentOptions>,\n            options?: angular.IComponentOptions\n        ) {\n            // make sure the function signature is correct, if not pass it trough to the original function to handle errors\n            if (typeof nameOrDict === \"string\" && typeof options !== \"object\")\n                return registerComponent.call(this, nameOrDict, options as any);\n            if (\n                typeof nameOrDict !== \"string\" &&\n                typeof nameOrDict !== \"object\"\n            )\n                return registerComponent.call(this, nameOrDict, options as any);\n\n            // create the dictionary call signature as it is easier to work with\n            const components: Dict<angular.IComponentOptions> =\n                typeof nameOrDict === \"string\"\n                    ? { [nameOrDict]: options! }\n                    : nameOrDict;\n\n            for (const key in components) {\n                const options = components[key];\n\n                // check if it has a controller function\n                if (typeof options.controller !== \"function\") continue;\n\n                // check if it has a `static $defaults` property, use `getOwnPropertyNames` to check for a getter function without invoking it\n                if (\n                    Object.getOwnPropertyNames(options.controller).indexOf(\n                        \"$defaults\"\n                    ) === -1\n                )\n                    continue;\n\n                // get the original `$onInit` function or undefined if there was none\n                const onInit: Function | undefined =\n                    options.controller.prototype.$onInit;\n\n                // patch the `$onInit` function\n                options.controller.prototype.$onInit = function $onInit() {\n                    const defaults = (options.controller as Dict).$defaults;\n\n                    if (typeof defaults === \"object\") {\n                        for (const prop in defaults) {\n                            if (this[prop] == null) {\n                                this[prop] = defaults[prop];\n                            }\n                        }\n                    }\n\n                    // call the lifecycle hook if it existed\n                    return typeof onInit === \"function\"\n                        ? onInit.call(this)\n                        : void 0;\n                };\n            }\n\n            return registerComponent.call(this, components);\n        }\n    }\n})();\n"]}